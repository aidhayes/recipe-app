import * as React from 'react';
import React__default, { useContext, useRef, useEffect, useCallback, createContext, useMemo, useState, useReducer } from 'react';
import classNames from 'classnames';
import PropTypes from 'prop-types';
import { Collapse, NavLink, Anchor, NavbarBrand } from 'react-bootstrap';

function _extends$1() {
  _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$1.apply(this, arguments);
}

function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose$1(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

const SelectableContext = /*#__PURE__*/React.createContext(null);
const makeEventKey = (eventKey, href = null) => {
  if (eventKey != null) return String(eventKey);
  return href || null;
};

var jsxRuntime = {exports: {}};

var reactJsxRuntime_production_min = {};

/** @license React v16.14.0
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f=React__default,g=60103;reactJsxRuntime_production_min.Fragment=60107;if("function"===typeof Symbol&&Symbol.for){var h=Symbol.for;g=h("react.element");reactJsxRuntime_production_min.Fragment=h("react.fragment");}var m=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,n=Object.prototype.hasOwnProperty,p={key:!0,ref:!0,__self:!0,__source:!0};
function q(c,a,k){var b,d={},e=null,l=null;void 0!==k&&(e=""+k);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(l=a.ref);for(b in a)n.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return {$$typeof:g,type:c,key:e,ref:l,props:d,_owner:m.current}}reactJsxRuntime_production_min.jsx=q;reactJsxRuntime_production_min.jsxs=q;

var reactJsxRuntime_development = {};

/** @license React v16.14.0
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

(function (exports) {

if (process.env.NODE_ENV !== "production") {
  (function() {

var React = React__default;

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  symbolFor('react.scope');
  symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = '';

    if (currentlyValidatingElement) {
      var name = getComponentName(currentlyValidatingElement.type);
      var owner = currentlyValidatingElement._owner;
      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
    }

    stack += ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}


var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
function describeComponentFrame (name, source, ownerName) {
  var sourceInfo = '';

  if (source) {
    var path = source.fileName;
    var fileName = path.replace(BEFORE_SLASH_RE, '');

    {
      // In DEV, include code for a common special case:
      // prefer "folder/index.js" instead of just "index.js".
      if (/^index\./.test(fileName)) {
        var match = path.match(BEFORE_SLASH_RE);

        if (match) {
          var pathBeforeSlash = match[1];

          if (pathBeforeSlash) {
            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
            fileName = folderName + '/' + fileName;
          }
        }
      }
    }

    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
  } else if (ownerName) {
    sourceInfo = ' (created by ' + ownerName + ')';
  }

  return '\n    in ' + (name || 'Unknown') + sourceInfo;
}

var Resolved = 1;
function refineResolvedLazyComponent(lazyComponent) {
  return lazyComponent._status === Resolved ? lazyComponent._result : null;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return "Profiler";

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return 'Context.Consumer';

      case REACT_PROVIDER_TYPE:
        return 'Context.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type.render);

      case REACT_LAZY_TYPE:
        {
          var thenable = type;
          var resolvedThenable = refineResolvedLazyComponent(thenable);

          if (resolvedThenable) {
            return getComponentName(resolvedThenable);
          }

          break;
        }
    }
  }

  return null;
}

var loggedTypeFailures = {};
ReactSharedInternals.ReactDebugCurrentFrame;
var currentlyValidatingElement = null;

function setCurrentlyValidatingElement(element) {
  {
    currentlyValidatingElement = element;
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  currentlyValidatingElement = element;
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentName(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (Array.isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (Array.isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    if (type === exports.Fragment) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev
// even with the prod transform. This means that jsxDEV is purely
// opt-in behavior for better messages but that we won't stop
// giving you warnings if you use production apis.

function jsxWithValidationStatic(type, props, key) {
  {
    return jsxWithValidation(type, props, key, true);
  }
}
function jsxWithValidationDynamic(type, props, key) {
  {
    return jsxWithValidation(type, props, key, false);
  }
}

var jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.
// for now we can ship identical prod functions

var jsxs =  jsxWithValidationStatic ;

exports.jsx = jsx;
exports.jsxs = jsxs;
  })();
}
}(reactJsxRuntime_development));

if (process.env.NODE_ENV === 'production') {
  jsxRuntime.exports = reactJsxRuntime_production_min;
} else {
  jsxRuntime.exports = reactJsxRuntime_development;
}

const DEFAULT_BREAKPOINTS = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];
const ThemeContext = /*#__PURE__*/React.createContext({
  prefixes: {},
  breakpoints: DEFAULT_BREAKPOINTS
});

function useBootstrapPrefix(prefix, defaultPrefix) {
  const {
    prefixes
  } = useContext(ThemeContext);
  return prefix || prefixes[defaultPrefix] || defaultPrefix;
}

/**
 * Creates a `Ref` whose value is updated in an effect, ensuring the most recent
 * value is the one rendered with. Generally only required for Concurrent mode usage
 * where previous work in `render()` may be discarded before being used.
 *
 * This is safe to access in an event handler.
 *
 * @param value The `Ref` value
 */

function useCommittedRef(value) {
  var ref = useRef(value);
  useEffect(function () {
    ref.current = value;
  }, [value]);
  return ref;
}

function useEventCallback(fn) {
  var ref = useCommittedRef(fn);
  return useCallback(function () {
    return ref.current && ref.current.apply(ref, arguments);
  }, [ref]);
}

var SidebarMenuContext = /*#__PURE__*/createContext({});

var _excluded$b = ["as", "children", "onClick", "bsPrefix", "className", "label"];
var propTypes$5 = {
  /** @default 'sidebar-menu-toggler' */
  bsPrefix: PropTypes.string,

  /** An accessible ARIA label for the toggler button. */
  label: PropTypes.string,

  /** @private */
  onClick: PropTypes.func,

  /**
   * The toggle content. When empty, the default toggle will be rendered.
   */
  children: PropTypes.node,
  as: PropTypes.elementType,
  className: PropTypes.string
};
var defaultProps$4 = {
  label: 'Toggle navigation'
};
var SidebarMenuToggle = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var _ref$as = _ref.as,
      Component = _ref$as === void 0 ? 'button' : _ref$as,
      children = _ref.children,
      onClick = _ref.onClick,
      bsPrefix = _ref.bsPrefix,
      className = _ref.className,
      label = _ref.label,
      props = _objectWithoutProperties(_ref, _excluded$b);

  bsPrefix = useBootstrapPrefix(bsPrefix, 'sidebar-menu-toggle');

  var _ref2 = useContext(SidebarMenuContext) || {},
      onToggle = _ref2.onToggle,
      expanded = _ref2.expanded;

  var handleOnClick = useEventCallback(function (e) {
    onClick === null || onClick === void 0 ? void 0 : onClick(e);
    onToggle === null || onToggle === void 0 ? void 0 : onToggle();
  });

  if (Component === 'button') {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    props.type = 'button';
  }

  return /*#__PURE__*/React__default.createElement(Component, _extends$1({
    ref: ref
  }, props, {
    onClick: handleOnClick,
    className: classNames(className, bsPrefix, !expanded && 'collapsed'),
    "aria-label": label
  }), children || /*#__PURE__*/React__default.createElement("span", {
    className: "".concat(bsPrefix, "-icon")
  }));
});
SidebarMenuToggle.displayName = "SidebarMenuToggler";
SidebarMenuToggle.propTypes = propTypes$5;
SidebarMenuToggle.defaultProps = defaultProps$4;

/**
 * Safe chained function
 *
 * Will only create a new function if needed,
 * otherwise will pass back existing functions or null.
 *
 * @param {function} functions to chain
 * @returns {function|null}
 */
function createChainedFunction(...funcs) {
  return funcs.filter(f => f != null).reduce((acc, f) => {
    if (typeof f !== 'function') {
      throw new Error('Invalid Argument Type, must only provide functions, undefined, or null.');
    }

    if (acc === null) return f;
    return function chainedFunction(...args) {
      // @ts-ignore
      acc.apply(this, args); // @ts-ignore

      f.apply(this, args);
    };
  }, null);
}

var _excluded$a = ["dimension", "getScrollValue", "children", "onEntering", "className", "bsPrefix"];
var SidebarMenuCollapse = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var _ref$dimension = _ref.dimension,
      dimension = _ref$dimension === void 0 ? 'width' : _ref$dimension,
      _ref$getScrollValue = _ref.getScrollValue,
      getScrollValue = _ref$getScrollValue === void 0 ? function () {
    return 300;
  } : _ref$getScrollValue,
      children = _ref.children,
      onEntering = _ref.onEntering,
      className = _ref.className,
      initialBsPrefix = _ref.bsPrefix,
      props = _objectWithoutProperties(_ref, _excluded$a);

  var computedDimension = typeof dimension === 'function' ? dimension() : dimension;
  var sidebarMenuContext = useContext(SidebarMenuContext);
  var bsPrefix = useBootstrapPrefix(initialBsPrefix, 'sidebar-menu-collapse');
  var handleEntering = useMemo(function () {
    return createChainedFunction(function (elem) {
      if (typeof getScrollValue === 'function') {
        var scrollValue = getScrollValue(elem);
        elem.style[computedDimension] = typeof scrollValue === 'string' ? scrollValue : "".concat(scrollValue, "px");
      } else if (typeof getScrollValue === 'number') {
        elem.style[computedDimension] = "".concat(getScrollValue, "px");
      } else if (typeof getScrollValue === 'string') {
        elem.style[computedDimension] = getScrollValue;
      }
    }, onEntering);
  }, [computedDimension, getScrollValue, onEntering]);
  return /*#__PURE__*/React__default.createElement(Collapse, _extends$1({}, props, {
    dimension: dimension,
    onEntering: handleEntering,
    "in": !!(sidebarMenuContext !== null && sidebarMenuContext !== void 0 && sidebarMenuContext.expanded)
  }), /*#__PURE__*/React__default.createElement("div", {
    ref: ref,
    className: classNames(className, bsPrefix)
  }, children));
});
SidebarMenuCollapse.displayName = "SidebarMenuCollapse";
SidebarMenuCollapse.propTypes = Collapse.propTypes;

const NavContext = /*#__PURE__*/React.createContext(null);
NavContext.displayName = 'NavContext';

var SidebarMenuNodeContext = /*#__PURE__*/React.createContext({});

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var __DEV__ = process.env.NODE_ENV !== 'production';

var warning = function() {};

if (__DEV__) {
  var printWarning = function printWarning(format, args) {
    var len = arguments.length;
    args = new Array(len > 1 ? len - 1 : 0);
    for (var key = 1; key < len; key++) {
      args[key - 1] = arguments[key];
    }
    var argIndex = 0;
    var message = 'Warning: ' +
      format.replace(/%s/g, function() {
        return args[argIndex++];
      });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
          '`warning(condition, format, ...args)` requires a warning ' +
          'message argument'
      );
    }
    if (!condition) {
      printWarning.apply(null, [format].concat(args));
    }
  };
}

var warning_1 = warning;

var _excluded$9 = ["active", "className", "eventKey", "onSelect", "onClick", "as"];
var propTypes$4 = {
  id: PropTypes.string,
  active: PropTypes.bool,
  role: PropTypes.string,
  href: PropTypes.string,
  tabIndex: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  eventKey: PropTypes.any,
  as: PropTypes.any,
  onClick: PropTypes.func,
  onSelect: PropTypes.func,
  'aria-controls': PropTypes.string
};
var defaultProps$3 = {
  disabled: false
};
var BaseNavItem = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var active = _ref.active,
      className = _ref.className,
      eventKey = _ref.eventKey,
      onSelect = _ref.onSelect,
      onClick = _ref.onClick,
      Component = _ref.as,
      props = _objectWithoutProperties(_ref, _excluded$9);

  var navKey = makeEventKey(eventKey, props.href);
  var parentOnSelect = useContext(SelectableContext);
  var navContext = useContext(NavContext);
  var isActive = active;

  if (navContext) {
    if (!props.role && navContext.role === 'tablist') props.role = 'tab';
    var contextControllerId = navContext.getControllerId(navKey);
    var contextControlledId = navContext.getControlledId(navKey);
    warning_1(!contextControllerId || !props.id, "[react-bootstrap] The provided id '".concat(props.id, "' was overwritten by the current navContext with '").concat(contextControllerId, "'."));
    warning_1(!contextControlledId || !props['aria-controls'], "[react-bootstrap] The provided aria-controls value '".concat(props['aria-controls'], "' was overwritten by the current navContext with '").concat(contextControlledId, "'."));
    props['data-rb-event-key'] = navKey;
    props.id = contextControllerId || props.id;
    props['aria-controls'] = contextControlledId || props['aria-controls'];
    isActive = active == null && navKey != null ? navContext.activeKey === navKey : active;
  }

  var handleOnClick = useEventCallback(function (event) {
    onClick === null || onClick === void 0 ? void 0 : onClick(event);

    if (navKey == null) {
      return;
    }

    onSelect === null || onSelect === void 0 ? void 0 : onSelect(navKey, event);
    parentOnSelect === null || parentOnSelect === void 0 ? void 0 : parentOnSelect(navKey, event);
  });
  return /*#__PURE__*/React__default.createElement(Component, _extends$1({}, props, {
    ref: ref,
    onClick: handleOnClick,
    className: classNames(className, isActive && 'active')
  }));
});
BaseNavItem.propTypes = propTypes$4;
BaseNavItem.defaultProps = defaultProps$3;
BaseNavItem.displayName = 'BaseNavItem';

var _excluded$8 = ["bsPrefix", "as", "className", "eventKey", "active", "disabled"];
var defaultProps$2 = {
  disabled: false
};
var SidebarMenuNavLink = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var initialBsPrefix = _ref.bsPrefix,
      _ref$as = _ref.as,
      As = _ref$as === void 0 ? Anchor : _ref$as,
      className = _ref.className,
      eventKey = _ref.eventKey,
      active = _ref.active,
      disabled = _ref.disabled,
      props = _objectWithoutProperties(_ref, _excluded$8);

  var bsPrefix = useBootstrapPrefix(initialBsPrefix, 'sidebar-menu-nav-link');

  var _useContext = useContext(SidebarMenuNodeContext),
      onActiveKeyChanged = _useContext.onActiveKeyChanged;

  var navContext = useContext(NavContext);
  var navKey = makeEventKey(eventKey, props.href);
  var isActive = active == null && navKey != null ? navContext && navContext.activeKey === navKey : active;
  useEffect(function () {
    isActive && (onActiveKeyChanged === null || onActiveKeyChanged === void 0 ? void 0 : onActiveKeyChanged(navKey));
  }, [isActive, navKey, onActiveKeyChanged]);
  return /*#__PURE__*/React__default.createElement(BaseNavItem, _extends$1({
    ref: ref,
    as: As,
    active: active,
    eventKey: eventKey,
    disabled: disabled,
    className: classNames(className, bsPrefix, disabled && 'disabled')
  }, props));
});
SidebarMenuNavLink.displayName = "SidebarMenuNavLink";
SidebarMenuNavLink.propTypes = NavLink.propTypes;
SidebarMenuNavLink.defaultProps = defaultProps$2;

var rHyphen = /-(.)/g;
function camelize(string) {
  return string.replace(rHyphen, function (_, chr) {
    return chr.toUpperCase();
  });
}

const pascalCase = str => str[0].toUpperCase() + camelize(str).slice(1);

// TODO: emstricten & fix the typing here! `createWithBsPrefix<TElementType>...`
function createWithBsPrefix(prefix, {
  displayName = pascalCase(prefix),
  Component,
  defaultProps
} = {}) {
  const BsComponent = /*#__PURE__*/React.forwardRef(({
    className,
    bsPrefix,
    as: Tag = Component || 'div',
    ...props
  }, ref) => {
    const resolvedPrefix = useBootstrapPrefix(bsPrefix, prefix);
    return /*#__PURE__*/jsxRuntime.exports.jsx(Tag, {
      ref: ref,
      className: classNames(className, resolvedPrefix),
      ...props
    });
  });
  BsComponent.defaultProps = defaultProps;
  BsComponent.displayName = displayName;
  return BsComponent;
}

var SidebarMenuNavItem = createWithBsPrefix('sidebar-menu-nav-item');

var SidebarMenuNavIcon = createWithBsPrefix('sidebar-menu-nav-icon', {
  displayName: 'SidebarMenuNavIcon',
  Component: 'span'
});

var SidebarMenuNavTitle = createWithBsPrefix('sidebar-menu-nav-title', {
  displayName: 'SidebarMenuNavTitle',
  Component: 'span'
});

var _excluded$7 = ["bsPrefix", "as", "className"];
var propTypes$3 = {
  /** @default 'sidebar-menu-nav' */
  bsPrefix: PropTypes.string,

  /**
   * The underlying HTML element to use when rendering the SidebarMenuNav.
   *
   * @type {('input'|elementType)}
   */
  as: PropTypes.elementType,
  className: PropTypes.string
};
var SidebarMenuNav = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var initialBsPrefix = _ref.bsPrefix,
      _ref$as = _ref.as,
      Component = _ref$as === void 0 ? 'div' : _ref$as,
      className = _ref.className,
      props = _objectWithoutProperties(_ref, _excluded$7);

  var bsPrefix = useBootstrapPrefix(initialBsPrefix, 'sidebar-menu-nav');
  return /*#__PURE__*/React__default.createElement(Component, _extends$1({
    ref: ref
  }, props, {
    className: classNames(className, bsPrefix)
  }));
});
SidebarMenuNav.displayName = 'SidebarMenuNav';
SidebarMenuNav.propTypes = propTypes$3;
var SidebarMenuNav$1 = Object.assign(SidebarMenuNav, {
  Item: SidebarMenuNavItem,
  Link: SidebarMenuNavLink,
  Icon: SidebarMenuNavIcon,
  Title: SidebarMenuNavTitle
});

var _excluded$6 = ["bsPrefix"];
var SidebarMenuBrand = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var initialBsPrefix = _ref.bsPrefix,
      props = _objectWithoutProperties(_ref, _excluded$6);

  var bsPrefix = useBootstrapPrefix(initialBsPrefix, 'sidebar-menu-brand');
  return /*#__PURE__*/React__default.createElement(NavbarBrand, _extends$1({
    ref: ref,
    bsPrefix: bsPrefix
  }, props));
});
SidebarMenuBrand.displayName = "SidebarMenuBrand";

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

process.env.NODE_ENV;

function defaultKey(key) {
  return 'default' + key.charAt(0).toUpperCase() + key.substr(1);
}

function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }

function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }

function useUncontrolledProp(propValue, defaultValue, handler) {
  var wasPropRef = useRef(propValue !== undefined);

  var _useState = useState(defaultValue),
      stateValue = _useState[0],
      setState = _useState[1];

  var isProp = propValue !== undefined;
  var wasProp = wasPropRef.current;
  wasPropRef.current = isProp;
  /**
   * If a prop switches from controlled to Uncontrolled
   * reset its value to the defaultValue
   */

  if (!isProp && wasProp && stateValue !== defaultValue) {
    setState(defaultValue);
  }

  return [isProp ? propValue : stateValue, useCallback(function (value) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (handler) handler.apply(void 0, [value].concat(args));
    setState(value);
  }, [handler])];
}
function useUncontrolled(props, config) {
  return Object.keys(config).reduce(function (result, fieldName) {
    var _extends2;

    var _ref = result,
        defaultValue = _ref[defaultKey(fieldName)],
        propsValue = _ref[fieldName],
        rest = _objectWithoutPropertiesLoose(_ref, [defaultKey(fieldName), fieldName].map(_toPropertyKey));

    var handlerName = config[fieldName];

    var _useUncontrolledProp = useUncontrolledProp(propsValue, defaultValue, props[handlerName]),
        value = _useUncontrolledProp[0],
        handler = _useUncontrolledProp[1];

    return _extends({}, rest, (_extends2 = {}, _extends2[fieldName] = value, _extends2[handlerName] = handler, _extends2));
  }, props);
}

var context$1 = /*#__PURE__*/React.createContext({});
context$1.displayName = 'SidebarMenuSubContext';

const context = /*#__PURE__*/React.createContext(null);
context.displayName = 'NavbarContext';
var NavbarContext = context;

const defaultProps$1 = {
  label: 'Toggle navigation'
};
const NavbarToggle = /*#__PURE__*/React.forwardRef(({
  bsPrefix,
  className,
  children,
  label,
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  as: Component = 'button',
  onClick,
  ...props
}, ref) => {
  bsPrefix = useBootstrapPrefix(bsPrefix, 'navbar-toggler');
  const {
    onToggle,
    expanded
  } = useContext(NavbarContext) || {};
  const handleClick = useEventCallback(e => {
    if (onClick) onClick(e);
    if (onToggle) onToggle();
  });

  if (Component === 'button') {
    props.type = 'button';
  }

  return /*#__PURE__*/jsxRuntime.exports.jsx(Component, { ...props,
    ref: ref,
    onClick: handleClick,
    "aria-label": label,
    className: classNames(className, bsPrefix, !expanded && 'collapsed'),
    children: children || /*#__PURE__*/jsxRuntime.exports.jsx("span", {
      className: `${bsPrefix}-icon`
    })
  });
});
NavbarToggle.displayName = 'NavbarToggle';
NavbarToggle.defaultProps = defaultProps$1;

var _excluded$5 = ["bsPrefix", "onClick", "className", "as", "children", "label"];
var SidebarMenuSubToggle = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var initialBsPrefix = _ref.bsPrefix,
      onClick = _ref.onClick,
      className = _ref.className,
      _ref$as = _ref.as,
      Component = _ref$as === void 0 ? 'button' : _ref$as,
      children = _ref.children,
      label = _ref.label,
      props = _objectWithoutProperties(_ref, _excluded$5);

  var bsPrefix = useBootstrapPrefix(initialBsPrefix, 'sidebar-menu-sub-toggle');

  var _useContext = useContext(context$1),
      activeKey = _useContext.activeKey,
      onSelect = _useContext.onSelect,
      onToggle = _useContext.onToggle,
      expanded = _useContext.expanded;

  var _useContext2 = useContext(context$1),
      eventKey = _useContext2.eventKey;

  var handleOnClick = useMemo(function () {
    return function () {
      var eventKeyPassed = eventKey === activeKey ? null : eventKey;
      onSelect === null || onSelect === void 0 ? void 0 : onSelect(eventKeyPassed);
    };
  }, [eventKey, activeKey, onSelect]);
  var handleClick = useEventCallback(function (e) {
    onClick === null || onClick === void 0 ? void 0 : onClick(e);
    onToggle === null || onToggle === void 0 ? void 0 : onToggle();
    handleOnClick();
  });

  if (Component === 'button') {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    props.type = 'button';
  }

  return /*#__PURE__*/React__default.createElement(Component, _extends$1({}, props, {
    ref: ref,
    onClick: handleClick,
    "aria-label": label,
    className: classNames(className, bsPrefix, !expanded && 'collapsed')
  }), children || /*#__PURE__*/React__default.createElement("span", {
    className: "".concat(bsPrefix, "-icon")
  }));
});
SidebarMenuSubToggle.displayName = "SidebarMenuSubToggle";
SidebarMenuSubToggle.propTypes = NavbarToggle.propTypes;
SidebarMenuSubToggle.defaultProps = NavbarToggle.defaultProps;

var _excluded$4 = ["children", "bsPrefix", "className"];
var SidebarMenuSubCollapse = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      initialBsPrefix = _ref.bsPrefix,
      className = _ref.className,
      props = _objectWithoutProperties(_ref, _excluded$4);

  var bsPrefix = useBootstrapPrefix(initialBsPrefix, 'sidebar-menu-sub-collapse');
  var subContext = useContext(context$1);
  return /*#__PURE__*/React.createElement(Collapse, _extends$1({
    "in": !!(subContext && subContext.expanded)
  }, props), /*#__PURE__*/React.createElement("div", {
    ref: ref,
    className: classNames(bsPrefix, className)
  }, children));
});
SidebarMenuSubCollapse.displayName = 'SidebarMenuSubCollapse';
SidebarMenuSubCollapse.propTypes = Collapse.propTypes;

var _excluded$3 = ["with", "onActiveKeyChanged"],
    _excluded2$2 = ["activeNodeKey", "onNodeSelect"];

var SidebarMenuNode = function SidebarMenuNode(_ref) {
  var With = _ref["with"],
      onActiveKeyChanged = _ref.onActiveKeyChanged,
      props = _objectWithoutProperties(_ref, _excluded$3);

  var _useUncontrolled = useUncontrolled(props, {
    activeNodeKey: 'onNodeSelect'
  }),
      activeNodeKey = _useUncontrolled.activeNodeKey,
      onNodeSelect = _useUncontrolled.onNodeSelect,
      controlledProps = _objectWithoutProperties(_useUncontrolled, _excluded2$2);

  var nodeContextValue = useMemo(function () {
    return {
      onActiveKeyChanged: onActiveKeyChanged,
      onSelect: onNodeSelect,
      activeKey: activeNodeKey
    };
  }, [activeNodeKey, onActiveKeyChanged, onNodeSelect]);
  return /*#__PURE__*/React__default.createElement(SidebarMenuNodeContext.Provider, {
    value: nodeContextValue
  }, /*#__PURE__*/React__default.createElement(With, controlledProps));
};

var _excluded$2 = ["bsPrefix", "as", "eventKey", "className"],
    _excluded2$1 = ["expanded", "onToggle"];
var propTypes$2 = {
  /**
   * Set a custom element for this component.
   */
  as: PropTypes.elementType,

  /**
   * A callback fired when the `<SidebarMenuSub>` body collapses or expands. Fired when
   * a `<SidebarMenuSub.Toggle>` is clicked and called with the new `expanded`
   * boolean value.
   *
   * @controllable expanded
   */
  onToggle: PropTypes.func,

  /**
   * Controls the visiblity of the submenu body
   *
   * @controllable onToggle
   */
  expanded: PropTypes.bool,

  /**
   * The ARIA role for the SidebarMenuSub.
   *
   * @default 'navigation'
   */
  role: PropTypes.string,

  /**
   * 
   */
  defaultExpanded: PropTypes.bool
};
var SidebarMenuSub = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var _navContext$activeKey;

  var initialBsPrefix = _ref.bsPrefix,
      _ref$as = _ref.as,
      Component = _ref$as === void 0 ? 'div' : _ref$as,
      eventKey = _ref.eventKey,
      className = _ref.className,
      props = _objectWithoutProperties(_ref, _excluded$2);

  var _useUncontrolled = useUncontrolled(props, {
    expanded: 'onToggle'
  }),
      expanded = _useUncontrolled.expanded,
      _onToggle = _useUncontrolled.onToggle,
      controlledProps = _objectWithoutProperties(_useUncontrolled, _excluded2$1);

  var bsPrefix = useBootstrapPrefix(initialBsPrefix, 'sidebar-menu-sub');

  var _useContext = useContext(SidebarMenuNodeContext),
      parentNodeActiveKey = _useContext.activeKey,
      onParentSelect = _useContext.onSelect,
      onParentActiveKeyChanged = _useContext.onActiveKeyChanged;

  var _useContext2 = useContext(SidebarMenuContext),
      exclusiveExpand = _useContext2.exclusiveExpand;

  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      activeKey = _useState2[0],
      setActiveKey = _useState2[1];

  var navContext = useContext(NavContext);
  var currentActiveKey = (_navContext$activeKey = navContext === null || navContext === void 0 ? void 0 : navContext.activeKey) !== null && _navContext$activeKey !== void 0 ? _navContext$activeKey : null;
  var subContextValue = useMemo(function () {
    return {
      bsPrefix: bsPrefix,
      eventKey: eventKey,
      onSelect: onParentSelect,
      activeKey: parentNodeActiveKey,
      onToggle: function onToggle() {
        return _onToggle === null || _onToggle === void 0 ? void 0 : _onToggle(!expanded);
      },
      onActiveKeyChanged: onParentActiveKeyChanged,
      expanded: exclusiveExpand && typeof eventKey !== 'undefined' ? eventKey === parentNodeActiveKey : !!expanded
    };
  }, [bsPrefix, eventKey, exclusiveExpand, expanded, onParentSelect, _onToggle, parentNodeActiveKey, onParentActiveKeyChanged]);
  var onActiveKeyChanged = useMemo(function () {
    return createChainedFunction(function (eventKey) {
      return setActiveKey(eventKey);
    }, onParentActiveKeyChanged);
  }, [onParentActiveKeyChanged]);
  var activeKeyChangedCallback = useMemo(function () {
    return function (currentActiveKey) {
      if (currentActiveKey && currentActiveKey === activeKey) {
        exclusiveExpand ? onParentSelect === null || onParentSelect === void 0 ? void 0 : onParentSelect(eventKey) : _onToggle === null || _onToggle === void 0 ? void 0 : _onToggle(true);
      }
    };
  }, [activeKey, eventKey, exclusiveExpand, onParentSelect, _onToggle]);
  useEffect(function () {
    activeKeyChangedCallback(currentActiveKey);
  }, [currentActiveKey, activeKeyChangedCallback]);
  return /*#__PURE__*/React__default.createElement(context$1.Provider, {
    value: subContextValue
  }, /*#__PURE__*/React__default.createElement(SidebarMenuNode, _extends$1({
    "with": Component,
    ref: ref,
    onActiveKeyChanged: onActiveKeyChanged,
    className: classNames(className, bsPrefix)
  }, controlledProps)));
});
SidebarMenuSub.displayName = "SidebarMenuSub";
SidebarMenuSub.propTypes = propTypes$2;
var SidebarMenuSub$1 = Object.assign(SidebarMenuSub, {
  Collapse: SidebarMenuSubCollapse,
  Toggle: SidebarMenuSubToggle
});

var SidebarMenuHeader = createWithBsPrefix('sidebar-menu-header', {
  displayName: 'SidebarMenuHeader',
  Component: 'div'
});

var SidebarMenuBody = createWithBsPrefix('sidebar-menu-body', {
  displayName: 'SidebarMenuBody',
  Component: 'div'
});

var SidebarMenuFooter = createWithBsPrefix('sidebar-menu-footer', {
  displayName: 'SidebarMenuFooter',
  Component: 'div'
});

var SidebarMenuText = createWithBsPrefix('sidebar-menu-text', {
  displayName: 'SidebarMenuText',
  Component: 'span'
});

var toArray = Function.prototype.bind.call(Function.prototype.call, [].slice);
/**
 * Runs `querySelectorAll` on a given element.
 * 
 * @param element the element
 * @param selector the selector
 */

function qsa(element, selector) {
  return toArray(element.querySelectorAll(selector));
}

/**
 * Returns a function that triggers a component update. the hook equivalent to
 * `this.forceUpdate()` in a class component. In most cases using a state value directly
 * is preferable but may be required in some advanced usages of refs for interop or
 * when direct DOM manipulation is required.
 *
 * ```ts
 * const forceUpdate = useForceUpdate();
 *
 * const updateOnClick = useCallback(() => {
 *  forceUpdate()
 * }, [forceUpdate])
 *
 * return <button type="button" onClick={updateOnClick}>Hi there</button>
 * ```
 */

function useForceUpdate() {
  // The toggling state value is designed to defeat React optimizations for skipping
  // updates when they are stricting equal to the last state value
  var _useReducer = useReducer(function (state) {
    return !state;
  }, false),
      dispatch = _useReducer[1];

  return dispatch;
}

var toFnRef = function toFnRef(ref) {
  return !ref || typeof ref === 'function' ? ref : function (value) {
    ref.current = value;
  };
};

function mergeRefs(refA, refB) {
  var a = toFnRef(refA);
  var b = toFnRef(refB);
  return function (value) {
    if (a) a(value);
    if (b) b(value);
  };
}
/**
 * Create and returns a single callback ref composed from two other Refs.
 *
 * ```tsx
 * const Button = React.forwardRef((props, ref) => {
 *   const [element, attachRef] = useCallbackRef<HTMLButtonElement>();
 *   const mergedRef = useMergedRefs(ref, attachRef);
 *
 *   return <button ref={mergedRef} {...props}/>
 * })
 * ```
 *
 * @param refA A Callback or mutable Ref
 * @param refB A Callback or mutable Ref
 * @category refs
 */

function useMergedRefs(refA, refB) {
  return useMemo(function () {
    return mergeRefs(refA, refB);
  }, [refA, refB]);
}

var _excluded$1 = ["as", "onSelect", "activeKey", "onKeyDown", "getControlledId", "getControllerId", "role"];

// eslint-disable-next-line @typescript-eslint/no-explicit-any
var noop = function noop() {
  /**/
};

var propTypes$1 = {
  onSelect: PropTypes.func,
  as: PropTypes.elementType,
  role: PropTypes.string,

  /** @private */
  onKeyDown: PropTypes.func,

  /** @private */
  parentOnSelect: PropTypes.func,

  /** @private */
  getControlledId: PropTypes.func,

  /** @private */
  getControllerId: PropTypes.func,

  /** @private */
  activeKey: PropTypes.any
}; // TODO: is this correct?

var BaseNav = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var _ref$as = _ref.as,
      Component = _ref$as === void 0 ? 'ul' : _ref$as,
      onSelect = _ref.onSelect,
      activeKey = _ref.activeKey,
      onKeyDown = _ref.onKeyDown,
      getControlledId = _ref.getControlledId,
      getControllerId = _ref.getControllerId,
      role = _ref.role,
      props = _objectWithoutProperties(_ref, _excluded$1);

  // A ref and forceUpdate for refocus, b/c we only want to trigger when needed
  // and don't want to reset the set in the effect
  var forceUpdate = useForceUpdate();
  var needsRefocusRef = useRef(false);
  var parentOnSelect = useContext(SelectableContext);
  var listNode = useRef(null);

  var getNextActiveChild = function getNextActiveChild(offset) {
    var currentListNode = listNode.current;
    if (!currentListNode) return null;
    var items = qsa(currentListNode, '[data-rb-event-key]:not(.disabled)');
    var activeChild = currentListNode.querySelector('.active');
    if (!activeChild) return null;
    var index = items.indexOf(activeChild);
    if (index === -1) return null;
    var nextIndex = index + offset;
    if (nextIndex >= items.length) nextIndex = 0;
    if (nextIndex < 0) nextIndex = items.length - 1;
    return items[nextIndex];
  };

  var handleSelect = function handleSelect(key, event) {
    if (key == null) return;
    if (onSelect) onSelect(key, event);
    if (parentOnSelect) parentOnSelect(key, event);
  };

  var handleKeyDown = function handleKeyDown(event) {
    var _nextActiveChild$data;

    if (onKeyDown) {
      onKeyDown(event);
    }

    var nextActiveChild;

    switch (event.nativeEvent.key) {
      case 'ArrowLeft':
      case 'ArrowUp':
        nextActiveChild = getNextActiveChild(-1);
        break;

      case 'ArrowRight':
      case 'ArrowDown':
        nextActiveChild = getNextActiveChild(1);
        break;

      default:
        return;
    }

    if (!nextActiveChild) return;
    event.preventDefault();
    handleSelect((_nextActiveChild$data = nextActiveChild.dataset.rbEventKey) !== null && _nextActiveChild$data !== void 0 ? _nextActiveChild$data : null, event);
    needsRefocusRef.current = true;
    forceUpdate();
  };

  useEffect(function () {
    if (listNode.current && needsRefocusRef.current) {
      var activeChild = listNode.current.querySelector('[data-rb-event-key].active');

      if (activeChild) {
        activeChild.focus();
      }
    }

    needsRefocusRef.current = false;
  });
  var mergedRef = useMergedRefs(ref, listNode);
  return /*#__PURE__*/React__default.createElement(SelectableContext.Provider, {
    value: handleSelect
  }, /*#__PURE__*/React__default.createElement(NavContext.Provider, {
    value: {
      role: role,
      // used by NavLink to determine it's role
      activeKey: makeEventKey(activeKey),
      getControlledId: getControlledId !== null && getControlledId !== void 0 ? getControlledId : noop,
      getControllerId: getControllerId !== null && getControllerId !== void 0 ? getControllerId : noop
    }
  }, /*#__PURE__*/React__default.createElement(Component, _extends$1({}, props, {
    onKeyDown: handleKeyDown,
    ref: mergedRef,
    role: role
  }))));
});
BaseNav.propTypes = propTypes$1;
BaseNav.displayName = 'BaseNav';

var _excluded = ["bsPrefix", "collapseOnSelect", "exclusiveExpand", "className", "variant", "expand", "hide", "bg", "rtl", "as"],
    _excluded2 = ["expanded", "onSelect", "activeKey", "onToggle"];
var propTypes = {
  /** @default 'sidebar-menu' */
  bsPrefix: PropTypes.string,

  /**
   * The general visual variant of the SidebarMenu.
   * Use in combination with the `bg` prop, `background-color` utilities,
   * or your own background styles.
   *
   * @type {('light'|'dark')}
   */
  variant: PropTypes.string,

  /**
   * RTL direction.
   * 
   * @default false
   */
  rtl: PropTypes.bool,

  /**
   * The breakpoint, below which, the SidebarMenu will collapse.
   * When `true` the SidebarMenu will always be expanded regardless of screen size.
   */
  expand: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['sm', 'md', 'lg', 'xl', 'xxl'])]).isRequired,

  /**
  * The breakpoint, below which, the SidebarMenu will hide.
  * When `true` the SidebarMenu will always be hidden regardless of screen size.
  * 
  * * @default false
  */
  hide: PropTypes.oneOf([true, false, 'sm', 'md', 'lg', 'xl', 'xxl']).isRequired,

  /**
   * Controls the visiblity of the sidebar body
   *
   * @controllable onToggle
   */
  expanded: PropTypes.bool,

  /**
   * A convenience prop for adding `bg-*` utility classes since they are so commonly used here.
   * `light` and `dark` are common choices but any `bg-*` class is supported, including any custom ones you might define.
   */
  bg: PropTypes.string,

  /**
   * Set a custom element for this component.
   */
  as: PropTypes.elementType,

  /**
   * A callback fired when the `<SidebarMenu>` body collapses or expands. Fired when
   * a `<SidebarMenu.Toggle>` is clicked and called with the new `expanded`
   * boolean value.
   *
   * @controllable expanded
   */
  onToggle: PropTypes.func,

  /**
   * A callback fired when a descendant of a child `<SidebarMenuNav>` is selected. Should
   * be used to execute complex closing or other miscellaneous actions desired
   * after selecting a descendant of `<SidebarMenuNav>`. Does nothing if no `<SidebarMenuNav>` or `<SidebarMenuNav>`
   * descendants exist. The callback is called with an eventKey, which is a
   * prop from the selected `<SidebarMenuNav>` descendant, and an event.
   *
   * ```js
   * function (
   *  eventKey: mixed,
   *  event?: SyntheticEvent
   * )
   * ```
   *
   * For basic closing behavior after all `<SidebarMenuNav>` descendant onSelect events in
   * mobile viewports, try using collapseOnSelect.
   *
   * Note: If you are manually closing the sidebar using this `OnSelect` prop,
   * ensure that you are setting `expanded` to false and not *toggling* between
   * true and false.
   */
  onSelect: PropTypes.func,

  /**
   * Toggles `expanded` to `false` after the onSelect event of a descendant of a
   * child `<SidebarMenu>` fires. Does nothing if no `<SidebarMenu>` or `<SidebarMenu>` descendants exist.
   *
   * Manually controlling `expanded` via the onSelect callback is recommended instead,
   * for more complex operations that need to be executed after
   * the `select` event of `<SidebarMenu>` descendants.
   */
  collapseOnSelect: PropTypes.bool,

  /**
   * Only allow one `<SidebarMenu.Sub.Collapse>` open at a time.
   */
  exclusiveExpand: PropTypes.bool,

  /**
   * The ARIA role for the sidebar, will default to 'navigation' for
   * SidebarMenu whose `as` is something other than `<nav>`.
   *
   * @default 'navigation'
   */
  role: PropTypes.string,

  /**
   * Marks the SidebarMenuNavItem with a matching `eventKey` (or `href` if present) as active.
   */
  activeKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
};
var defaultProps = {
  rtl: false,
  expand: true,
  hide: false,
  variant: 'light',
  collapseOnSelect: false,
  defaultExpanded: true
};
var SidebarMenu = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var initialBsPrefix = _ref.bsPrefix,
      collapseOnSelect = _ref.collapseOnSelect,
      exclusiveExpand = _ref.exclusiveExpand,
      className = _ref.className,
      variant = _ref.variant,
      expand = _ref.expand,
      hide = _ref.hide,
      bg = _ref.bg,
      rtl = _ref.rtl,
      _ref$as = _ref.as,
      Component = _ref$as === void 0 ? 'aside' : _ref$as,
      props = _objectWithoutProperties(_ref, _excluded);

  var _useUncontrolled = useUncontrolled(props, {
    expanded: 'onToggle',
    activeKey: 'onSelect'
  }),
      expanded = _useUncontrolled.expanded,
      onSelect = _useUncontrolled.onSelect,
      activeKey = _useUncontrolled.activeKey,
      _onToggle = _useUncontrolled.onToggle,
      controlledProps = _objectWithoutProperties(_useUncontrolled, _excluded2);

  var bsPrefix = useBootstrapPrefix(initialBsPrefix, 'sidebar-menu');
  var handleSelect = useCallback(function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    onSelect === null || onSelect === void 0 ? void 0 : onSelect.apply(void 0, args);

    if (collapseOnSelect && expanded) {
      _onToggle === null || _onToggle === void 0 ? void 0 : _onToggle(false);
    }
  }, [onSelect, collapseOnSelect, expanded, _onToggle]);

  if (controlledProps.role === undefined && Component !== 'nav') {
    controlledProps.role = 'navigation';
  }

  var expandClass = "".concat(bsPrefix, "-expand");

  if (typeof expand === 'string') {
    expandClass = "".concat(expandClass, "-").concat(expand);
  }

  var hideClass = "".concat(bsPrefix, "-hide");

  if (typeof hide === 'string') {
    hideClass = "".concat(hideClass, "-").concat(hide);
  }

  var sidebarMenuContextValue = useMemo(function () {
    return {
      rtl: !!rtl,
      expanded: !!expanded,
      onToggle: function onToggle() {
        return _onToggle === null || _onToggle === void 0 ? void 0 : _onToggle(!expanded);
      },
      exclusiveExpand: exclusiveExpand
    };
  }, [expanded, _onToggle, rtl, exclusiveExpand]);
  return /*#__PURE__*/React__default.createElement(SidebarMenuContext.Provider, {
    value: sidebarMenuContextValue
  }, /*#__PURE__*/React__default.createElement(SelectableContext.Provider, {
    value: handleSelect
  }, /*#__PURE__*/React__default.createElement(SidebarMenuNode, _extends$1({
    "with": BaseNav,
    as: Component,
    ref: ref,
    activeKey: activeKey,
    className: classNames(className, bsPrefix, hide && hideClass, expand && expandClass, expanded && 'show', rtl && "".concat(bsPrefix, "-rtl"), variant && "".concat(bsPrefix, "-").concat(variant), bg && "bg-".concat(bg))
  }, controlledProps))));
});
SidebarMenu.displayName = "SidebarMenu";
SidebarMenu.defaultProps = defaultProps;
SidebarMenu.propTypes = propTypes;
var SidebarMenu$1 = Object.assign(SidebarMenu, {
  Nav: SidebarMenuNav$1,
  Sub: SidebarMenuSub$1,
  Brand: SidebarMenuBrand,
  Collapse: SidebarMenuCollapse,
  Toggle: SidebarMenuToggle,
  Header: SidebarMenuHeader,
  Body: SidebarMenuBody,
  Footer: SidebarMenuFooter,
  Text: SidebarMenuText
});

export { SidebarMenuBody, SidebarMenuBrand, SidebarMenuCollapse, SidebarMenuContext, SidebarMenuFooter, SidebarMenuHeader, SidebarMenuNav$1 as SidebarMenuNav, SidebarMenuNavIcon, SidebarMenuNavItem, SidebarMenuNavLink, SidebarMenuNavTitle, SidebarMenuSub$1 as SidebarMenuSub, context$1 as SidebarMenuSubContext, SidebarMenu$1 as default };
